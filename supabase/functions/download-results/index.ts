import { serve } from "https://deno.land/std@0.208.0/http/server.ts";
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2.57.4';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

async function generatePDFReport(analysisData: any): Promise<Uint8Array> {
  // In a real implementation, this would generate a proper PDF using libraries like jsPDF
  // For now, return a simple text-based "PDF"
  const reportContent = `
SITE SUITABILITY ANALYSIS REPORT
================================

Project Type: ${analysisData.parameters?.project_type || 'Unknown'}
Analysis Date: ${new Date().toLocaleDateString()}
Region: ${analysisData.parameters?.region?.name || 'Unknown'}

SUMMARY
-------
Total Sites Found: ${analysisData.result_data?.topSites?.length || 0}
Best Site Score: ${((analysisData.result_data?.topSites?.[0]?.score || 0) * 100).toFixed(1)}%

TOP RECOMMENDED SITES
--------------------
${analysisData.result_data?.topSites?.slice(0, 5).map((site: any, index: number) => 
  `${index + 1}. Site #${index + 1}
     Score: ${(site.score * 100).toFixed(1)}%
     Area: ${site.area.toFixed(1)} hectares
     Coordinates: ${site.coordinates[1].toFixed(4)}, ${site.coordinates[0].toFixed(4)}`
).join('\n\n') || 'No sites found'}

CRITERIA BREAKDOWN
------------------
${Object.entries(analysisData.result_data?.breakdown || {}).map(([criterion, score]: [string, any]) => 
  `${criterion}: ${(score * 100).toFixed(1)}%`
).join('\n')}

---
Generated by Harita Hive GeoAI Platform
  `;

  return new TextEncoder().encode(reportContent);
}

async function generatePNGImage(analysisData: any): Promise<Uint8Array> {
  // In a real implementation, this would render the map as PNG
  // For now, return a simple 1x1 pixel PNG
  const pngData = new Uint8Array([
    0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, // PNG signature
    0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, // IHDR chunk
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, // 1x1 dimensions
    0x08, 0x02, 0x00, 0x00, 0x00, 0x90, 0x77, 0x53, 0xDE, // bit depth, color type, etc.
    0x00, 0x00, 0x00, 0x0C, 0x49, 0x44, 0x41, 0x54, // IDAT chunk
    0x08, 0x99, 0x01, 0x01, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, // data
    0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82 // IEND chunk
  ]);
  
  return pngData;
}

async function generateGeoTIFF(analysisData: any): Promise<Uint8Array> {
  // In a real implementation, this would generate a proper GeoTIFF with raster data
  // For now, return a minimal TIFF structure
  const tiffHeader = new Uint8Array([
    0x49, 0x49, // Little endian
    0x2A, 0x00, // TIFF magic number
    0x08, 0x00, 0x00, 0x00, // Offset to first IFD
  ]);
  
  return tiffHeader;
}

serve(async (req) => {
  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const supabase = createClient(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    if (req.method !== 'GET') {
      throw new Error('Method not allowed');
    }

    const url = new URL(req.url);
    const projectId = url.pathname.split('/').pop();
    const format = url.searchParams.get('format') || 'pdf';

    if (!projectId) {
      throw new Error('Project ID is required');
    }

    console.log(`Generating ${format} download for project ${projectId}`);

    // Fetch analysis results from database
    const { data: analysisData, error: fetchError } = await supabase
      .from('analysis_results')
      .select('*')
      .eq('id', projectId)
      .single();

    if (fetchError || !analysisData) {
      throw new Error('Analysis results not found');
    }

    let fileData: Uint8Array;
    let contentType: string;
    let filename: string;

    switch (format.toLowerCase()) {
      case 'pdf':
        fileData = await generatePDFReport(analysisData);
        contentType = 'application/pdf';
        filename = `suitability_analysis_${projectId}.pdf`;
        break;
      
      case 'png':
        fileData = await generatePNGImage(analysisData);
        contentType = 'image/png';
        filename = `suitability_map_${projectId}.png`;
        break;
      
      case 'geotiff':
        fileData = await generateGeoTIFF(analysisData);
        contentType = 'image/tiff';
        filename = `suitability_raster_${projectId}.tif`;
        break;
      
      default:
        throw new Error(`Unsupported format: ${format}`);
    }

    console.log(`Generated ${format} file: ${fileData.length} bytes`);

    return new Response(fileData, {
      headers: {
        ...corsHeaders,
        'Content-Type': contentType,
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Length': fileData.length.toString(),
      },
      status: 200,
    });

  } catch (error) {
    console.error('Download error:', error);
    
    return new Response(
      JSON.stringify({ 
        error: 'Download failed',
        details: error instanceof Error ? error.message : 'Unknown error'
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }
});